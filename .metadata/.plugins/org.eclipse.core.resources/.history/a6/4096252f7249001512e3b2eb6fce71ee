/*
 *
 *  Created on: Aug 22, 2015
 *      Author: Deepak K. Gupta
 *  
 */

#include <deal.II/grid/grid_generator.h>
#include <deal.II/grid/tria_accessor.h>
#include <deal.II/grid/tria_iterator.h>
#include <deal.II/grid/grid_out.h>
#include <deal.II/dofs/dof_handler.h>
#include <deal.II/dofs/dof_accessor.h>
#include <deal.II/dofs/dof_tools.h>
#include <deal.II/grid/tria.h>
#include <atop/TopologyOptimization/cell_prop.h>
#include <atop/physics/elasticity.h>
#include <atop/fem/define_mesh.h>

using namespace atop;
using namespace dealii;

template <int dim>
void Adaptivity<dim>::update(
		FEM<dim> &obj_fem){

	//Assigning the FEM object
	this->fem = &obj_fem;



	//Run projection adaptivity


	//Run penalization continuation


}

/**
 * This function chooses the right algorithm based on the provided
 * string to adaptively refine the FE mesh based on some density
 * criteria.
 */
template <int dim>
void Adaptivity<dim>::mesh_adaptivity_update(
		std::string &update_str){

	if(update_str == "ADAPTIVE_GRAYNESS"){
		if(fem->)
		coupled_refine_adaptive_grayness();
	}
}

template <int dim>
void Adaptivity<dim>::refine_adaptive_grayness(){

	//Getting the cycle number for refinement
	unsigned int cycle = fem->cycle;

	double rhomin = 0.0;
	double rhomax = 1.0;
	double rhomid = (rhomax + rhomin)/2;
	double alpha = 0.2;
	double beta = 1.2;

	double refine_lbound = rhomin + ((1 - alpha) * rhomid * exp(-beta * (double)(cycle+1)));
	double refine_ubound = rhomax - ((1 - alpha) * rhomid * exp(-beta * (double)(cycle+1)));
	double coarsen_lbound = rhomin + (alpha * rhomid * exp(-beta * (double)(cycle+1)));
	double coarsen_ubound = rhomax - (alpha * rhomid * exp(-beta * (double)(cycle+1)));

	typename Triangulation<dim>::active_cell_iterator cell = fem->triangulation.begin_active(),
			endc = fem->triangulation.end();

	typename Triangulation<dim>::active_cell_iterator density_cell = fem->density_triangulation.begin_active(),
			density_endc = fem->density_triangulation.end();

	unsigned int cell_itr = 0;

	for(; cell != endc; ++cell, ++density_cell){
		unsigned int n_qpoints = cellprop[cell_itr].material_density.size();
		double max_density = 1, min_density = 0;
		double total_weight = 0.0;
		double density = 0.0;
		unsigned int quad_index = elastic_data.get_quad_index(cellprop[cell_itr].quadrature_formula);
		for(unsigned int k = 0; k < elastic_data.JxW[quad_index].size(); ++k){
			total_weight += elastic_data.JxW[quad_index][k];
		}
		for(unsigned int qpoint = 0; qpoint < n_qpoints; ++qpoint){
			density += cellprop[cell_itr].xPhys[qpoint] *
								(elastic_data.JxW[quad_index][qpoint]/total_weight);

		}
		if(density > coarsen_ubound || density < coarsen_lbound){
			cell->set_coarsen_flag();
			density_cell->set_coarsen_flag();
		}
		else if (density > refine_lbound && density < refine_ubound) {
			cell->set_refine_flag();
			density_cell->set_refine_flag();
		}
		++cell_itr;
	}
}
